/// @brief  Strongly Connected Component - Kosaraju's algorithm implementation
/// @author z.skowron

#ifndef SCCKosaraju_H
#define SCCKosaraju_H

// Pseudo kod algorytmu Kosaraju - skomplikowany...
// Two DFS-es...
// See also this article:
// http://www.ccs.neu.edu/course/csu690/notes/strongly-conn-comp.html

#include <vector>
#include <queue>
#include <functional>
#include <limits>

#include "NeighbourListGraph.h"
#include "dfs-bfs.h"
#include "ZAssert.h"

/// @brief Computes strongly connected components of input graph.
/// @note  First SCC returned is one of the sink strongly connected components.
///        One of the source strongly connected components contains last node in dfs post traversal of graph.
///        Components are generated by Kosaraju's algorithm in topological order and by Tarjan's algorithm in reverse topological order.
template<typename EdgeType>
std::vector< std::vector<int> > SCCKosaraju(const NeighbourListGraph<EdgeType>& graph)
{
    std::vector< std::vector<int> > sccGroups;  // result: strongly connected components

    NeighbourListGraph<EdgeType> transposedGraph = graph.dumbTranspose();
        
    std::vector<int> postTraversal = dfs(graph, false);
    std::vector<bool> visited(graph.numberOfNodes);
    while (!postTraversal.empty())
    {
        int node = postTraversal.back();
        postTraversal.pop_back();
        // if we are in visited node - skip it
        if (visited[node])
        {
            continue;
        }

        std::vector<int> scc = dfsFromNode(node, transposedGraph, visited, true);
        sccGroups.push_back(scc);
    }

    return sccGroups;
}

#endif // SCCKosaraju_H
